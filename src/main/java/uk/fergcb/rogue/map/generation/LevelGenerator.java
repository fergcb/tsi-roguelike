package uk.fergcb.rogue.map.generation;

import uk.fergcb.rogue.map.Direction;
import uk.fergcb.rogue.map.Level;
import uk.fergcb.rogue.map.rooms.*;

import java.awt.*;
import java.lang.reflect.InvocationTargetException;
import java.util.HashMap;
import java.util.Map;
import java.util.Stack;

/**
 * The brain of the Level generation operation
 */
public class LevelGenerator {

    private final int width, height;
    private final Index index;

    public LevelGenerator(int width, int height) {
        this.width = width;
        this.height = height;
        this.index = new Index();

        buildIndex();
    }

    /**
     * Establish the rules for transitioning between rooms
     */
    private void buildIndex() {
        // A starter room always has a hallway to the east and nothing else
        index.addRule(StarterRoom.class, HorizontalHallway.class, 100, Direction.EAST);
        index.addRule(StarterRoom.class, null, 100, Direction.NORTH, Direction.SOUTH, Direction.WEST);

        // Empty rooms can neighbour other rooms, and hallways
        index.addRule(EmptyRoom.class, EmptyRoom.class, 20, Direction.values());
        index.addRule(EmptyRoom.class, HorizontalHallway.class, 30, Direction.EAST, Direction.WEST);
        index.addRule(EmptyRoom.class, VerticalHallway.class, 30, Direction.NORTH, Direction.SOUTH);
        index.addRule(EmptyRoom.class, null, 40, Direction.values());

        // Horizontal hallways may only join other rooms to the east and west
        index.addRule(HorizontalHallway.class, HorizontalHallway.class, 30, Direction.EAST, Direction.WEST);
        index.addRule(HorizontalHallway.class, EmptyRoom.class, 70, Direction.EAST, Direction.WEST);

        // Vertical hallways may only join other rooms to the north and south
        index.addRule(VerticalHallway.class, VerticalHallway.class, 30, Direction.NORTH, Direction.SOUTH);
        index.addRule(VerticalHallway.class, EmptyRoom.class, 70, Direction.NORTH, Direction.SOUTH);
    }

    /**
     * Check if a given point is outside the map
     * @param p The Point to check
     * @return true if the Point is outside the map, otherwise false
     */
    private boolean isOutOfBounds(Point p) {
        return p.x < 0 || p.y < 0 || p.x >= width || p.y >= height;
    }

    /**
     * Generate a new Level from scratch
     *
     * Levels are generated by creating the starting room and then using a depth-first traversal
     * This is done iteratively on a stacks to avoid a large recursion depth for larger maps
     *
     * @return The generated Level
     */
    public Level generateLevel() {
        final Map<Point, Room> generated = new HashMap<>();
        final Stack<Point> toExpand = new Stack<>();

        // Place the starter room in the middle of the map
        final int sx = width / 2;
        final int sy = height / 2;

        final Point starterPoint = new Point(sx, sy);
        final Room starterRoom = new StarterRoom(sx, sy);

        generated.put(starterPoint, starterRoom);
        toExpand.push(starterPoint);

        while (toExpand.size() > 0) {
            Point currentPoint = toExpand.pop();
            expand(currentPoint, generated, toExpand);
        }

        return new Level(width, height, starterRoom);
    }

    /**
     * Find the room at a given point and choose its neighbours. Mark the neighbours to be expanded.
     * @param currentPoint The point to expand
     * @param generated The set of generated rooms
     * @param toExpand The stack of points waiting to be expanded
     */
    private void expand(Point currentPoint,  Map<Point, Room> generated, Stack<Point> toExpand) {
        Room currentRoom = generated.get(currentPoint);

        for (Direction direction : Direction.values()) {
            Point vector = direction.vector;
            Point nextPoint = new Point(currentPoint.x + vector.x, currentPoint.y + vector.y);
            if (isOutOfBounds(nextPoint)) continue;

            // If this direction already has the desired room, just attach to it
            if (generated.containsKey(nextPoint)) {
                Room existingNeighbour = generated.get(nextPoint);
                if (index.isAllowed(currentRoom.getClass(), existingNeighbour.getClass(), direction)) {
                    currentRoom.attach(direction, existingNeighbour);
                }
                continue;
            }

            // Generate the new room
            Room nextRoom = createNextRoom(currentRoom, direction, nextPoint);
            if (nextRoom == null) continue;
            else currentRoom.attach(direction, nextRoom);

            // Attach the new room to the current one
            // Mark this point as having a generated room
            generated.put(nextPoint, nextRoom);
            // Remember to come back and explore the new room's neighbours
            toExpand.push(nextPoint);
        }
    }

    /**
     * Select the new room type and try to instantiate it
     * @param currentRoom The room being transitioned from
     * @param direction The outbound direction of travel
     * @param nextPoint The coordinates of the new room
     * @return the new Room, or null if no room should be placed here
     */
    private Room createNextRoom(Room currentRoom, Direction direction, Point nextPoint) {
        Class<? extends Room> nextRoomClass = index.chooseNext(currentRoom.getClass(), direction);
        if (nextRoomClass == null) return null;
        try {
            return nextRoomClass.getConstructor(int.class, int.class).newInstance(nextPoint.x, nextPoint.y);
        } catch (InstantiationException | IllegalAccessException | InvocationTargetException |
                 NoSuchMethodException e) {
            throw new RuntimeException(e);
        }
    }

}
